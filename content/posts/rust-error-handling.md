+++
title = "Rust Error Handling"
date = "2021-10-11T15:25:42+08:00"
draft = true
+++

程序在运行时出现错误是一个不可避免的事实，有些是代码 Bug，例如：数组越界，而其他错误则是由于和外部世界交互的原因，例如，网络错误，文件不存在。

Rust 尽可能地把代码 Bug 在编译期就找出来，然后给出详细的编译错误提示，让程序员修正。

但是仍然有些 Bug 很难在编译器检查出来，因此会在运行时 panic，对于这类错误，唯一的处理方法就是修正错误！

对于和外部世界交互产生的错误，Rust 提供了一套强大的错误处理机制，让 Rust 程序员轻松处理这些错误，编写出可靠性强，可维护性强的代码。

## Rust 的错误处理方法

对于一门编程语言，控制流程是其核心，而错误处理是控制流程中的重要组成部分。

错误处理设计的好，代码写起来才不会乱，心智负担也更小。

对于不可恢复的严重错误，Rust 使用一个宏 `panic!` 来直接终止 Rust 程序。

对于库来说，如果被非法地调用(严重错误)，可以 panic。对于应用和服务来说，永远也不应该 panic。

对于可以恢复的错误，Rust 使用一个枚举类型 `Result` 来表示。

```rust
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

变体 `Ok` 代表没有错误，里面可以包含一个正确的结果，变体 `Err` 表示错误发生，里面一般是一个表示错误信息的类型。

由于 `Result` 只是一个普通的枚举类型，因此可以用处理枚举类型的语法(match, if let)来处理错误。

Rust 的这种设计将错误处理流程完全融入正常的控制流程中，并不会像异常机制将两者割裂开，造成很多不便。

接下来用一个示例来演示 Rust 的错误处理，假设我们要编写一个函数将两个数字相减，如果 `a > b` 就返回 `Ok`，里面包含结果 `a - b`，而如果 `a < b`，由于我们的系统无法处理负数，就返回 `Err`，里面包含一个字符串表示错误信息，就是一个简单的字符串。

```rust
fn sub(a: u32, b: u32) -> Result<u32, &'static str> {
    if a > b {
        Ok(a - b)
    } else {
        Err("this function can't process negative number")
    }
}
```

调用函数 `sub` 返回的就是枚举类型 `Result`，没有任何隐式的规则和语法糖，这里就使用 match 来处理错误。

```rust
fn main() {
    let result = match sub(5, 3) {
        Ok(result) => result,
        Err(err) => {
            println!(err);
            return;
        }
    };
}
```

当然，你可以使用任何类型来描述错误，实际上，如果你不想要描述错误，甚至可以不用在变体 `Err` 中包含值，使用一个单元类型即可。

```rust
fn sub(a: u32, b: u32) -> Result<u32, ()> {
    if a > b {
        Ok(a - b)
    } else {
        Err(())
    }
}

fn main() {
    let result = match sub(5, 3) {
        Ok(result) => result,
        Err(_) => { // 即使不传递任何值，调用者也知道错误的发生
            println!("some error occurs in sub function);
            return;
        }
    };
}
```

接下来，我们会讨论，变体 `Err` 里面用什么类型最好。

## 错误类型


## 一点语法糖



## 和其他方法对比

错误处理一般都要设计哪些内容呢？
首先，我们需要用编程语言中的实体来表示错误，错误可以用数字表示，可以用类表示，也可以用实现了指定接口的类型表示。
错误捕获后，可以在当前函数内立即处理，也可以继续传给上游函数延迟处理，这就涉及到错误的传播。


目前错误处理有以下几种方法：
- 返回值(C)
- 异常机制
- 返回值(Go)
- 返回值+类型系统(Rust)



## anyhow

## thiserror

## 详解 panic

当 panic 发生时，程序会打印错误消息，向前回溯(unwind)并且清理栈，然后退出。

发生 panic 通常是程序有 bug 触发了 Rust 或者第三方库内部的严重错误，例如：数组越界。

unwind 和 clean 意味着大量的工作，替代的方法是立刻终止程序(abort)，可以在 `Cargo.toml` 中设置使用哪种方式。

```toml
# Cargo.toml
[profile.release]
panic = 'abort'
```

当你设计一个库时，什么时候调用 `panic!`，什么时候返回 `Result` 呢？

panic 意味着你代替调用者做出了一个决定，即出现这种情形，程序一定要终止，你对此很有信心。

返回 `Result` 则意味着你将决定权留给调用者。

绝大多数情况下，返回 `Result` 是更好的，但是有野心的库应该在适当的时候果断 panic。

### 几种可以 unwrap 的情况

当写示例代码时，如果写健壮的错误处理，可能会使示例很繁琐，不清晰，这个时候简单的 unwrap 是可以接受的。

原型代码也是这样，并且 unwrap, expect 还充当了很好的占位符，当想要程序更健壮的时候，可以很轻松发现这些标记。

在测试中调用 unwrap 是正常的，因为 panic 就是让测试失败的一种方法。

最后一种情况就是编译器还不够聪明，有的时候，你可以基于某些规则确定 Result 一定是 Ok，但是这个规则不是编译器可以理解的，这个时候，可以放心的 unwrap。

```rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1".parse().unwrap();
```


